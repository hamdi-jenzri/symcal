package com.github.symcal.javacompiler

import java.io.{ByteArrayInputStream, ByteArrayOutputStream, IOException, InputStream, OutputStream}
import java.net.URI
import java.util.function.DoubleUnaryOperator
import javax.tools.JavaFileObject.Kind
import javax.tools.{DiagnosticCollector, FileObject, ForwardingJavaFileManager, JavaCompiler, JavaFileManager, JavaFileObject, SimpleJavaFileObject, StandardJavaFileManager, StandardLocation, ToolProvider}

import com.github.symcal.JavaCompiledFunction

import scala.collection.JavaConverters.{asJavaIterableConverter, iterableAsScalaIterableConverter}
import scala.collection.mutable

/**
  * Compile a String or other [[CharSequence]], returning a Java
  * [[java.lang.Class]] instance that may be instantiated. This class is a Facade
  * around [[JavaCompiler]] for a narrower use case, but a bit easier to use.
  *
  * The source can be in a String, {@link StringBuffer}, or your own class which
  * implements {@link CharSequence}. If you implement your own, it must be
  * thread safe (preferably, immutable.)
  *
  * This was originally published at https://www.ibm.com/developerworks/java/library/j-jcomp/index.html
  *
  * @author <a href="mailto:David.Biesack@sas.com">David J. Biesack</a>
  */

object JavaInMemoryCompiler {
  val javaStringCompiler = new CharSequenceCompiler[DoubleUnaryOperator](this.getClass.getClassLoader, List("-target", "1.8"))

  def compile(fqClassName: String, javaCode: String): JavaCompiledFunction = {
    val aClass = javaStringCompiler.compile(fqClassName, javaCode)
    val runner = aClass.newInstance
    JavaCompiledFunction(runner)
  }

  // Compiler requires source files with a ".java" extension.
  val JAVA_EXTENSION: String = ".java"

  /*
One probably useful thing to add: the approach noted here won't work if your code resides inside a container so that actual codebase was loaded by a custom classloader (i.e. not the system one). For example if you try to use the method outlined above inside a J2EE container - trying to compile code that depends on the code already loaded into the container you will most probably fail. The reason is that StandardFileManager uses JVM classpath for resolving dependencies.
Here's a solution to overcoming this problem: http://atamur.blogspot.com/2009/10/using-built-in-javacompiler-with-custom.html
 */
  /**
    * Construct a new instance which delegates to the named class loader.
    *
    * @param loader  the application's [[ClassLoader]]. The compiler will look through to
    *                this class loader for dependent classes.
    * @param options The javac command-line options (such as "-target" "1.5").
    * @throws IllegalStateException if the Java compiler cannot be loaded.
    */
  final class CharSequenceCompiler[T](val loader: ClassLoader, val options: List[String]) {

    private val compiler =
      Option(ToolProvider.getSystemJavaCompiler)
        .getOrElse(throw new IllegalStateException("Cannot find the system Java compiler. Check that your class path includes tools.jar"))

    // This class loader delegates to the given `loader`.
    private val classLoader = new ClassLoaderImpl(loader)
    private val diagnostics = new DiagnosticCollector[JavaFileObject]
    private val standardJavaFileManager: StandardJavaFileManager = compiler.getStandardFileManager(diagnostics, null, null)
    // Workaround for class loaders that are running within a container.
    private val localFileManager: JavaFileManager = new CustomClassloaderJavaFileManager(loader, standardJavaFileManager)
    // This file manager delegates to the standard file manager.
    val javaFileManager = new FileManagerImpl(localFileManager, classLoader)

    /**
      * Compile Java source in <var>javaSource</name> and return the resulting class.
      * <p>
      * Thread safety: this method is thread safe if the <var>javaSource</var>
      * and <var>diagnosticsList</var> are isolated to this thread.
      *
      * @param qualifiedClassName A fully qualified class name.
      * @param javaSource         Complete Java source text, including a package statement and a class, interface, or annotation declaration.
      * @return a Class that is generated by compiling the Java source
      * @throws CharSequenceCompilerException if the source cannot be compiled - for example, if it contains syntax or semantic errors
      *                                       or if dependent classes cannot be found.
      */
    @throws[CharSequenceCompilerException]
    def compile(qualifiedClassName: String, javaSource: CharSequence): Class[T] = {
      val classes: Map[String, CharSequence] = Map(qualifiedClassName → javaSource)
      val compiled: Map[String, Class[T]] = compile(classes, diagnostics)
      compiled.getOrElse(qualifiedClassName, null)
    }

    /**
      * Compile multiple Java source strings and return a Map containing the
      * resulting classes.
      * <p>
      * Thread safety: this method is thread safe if the <var>classes</var> and
      * <var>diagnosticsList</var> are isolated to this thread.
      *
      * @param classes
      * A Map whose keys are qualified class names and whose values are
      * the Java source strings containing the definition of the class.
      * A map value may be null, indicating that compiled class is
      * expected, although no source exists for it (it may be a
      * non-public class contained in one of the other strings.)
      * @param diagnosticsList
      * Any diagnostics generated by compiling the source are added to
      * this list.
      * @return A mapping of qualified class names to their corresponding classes.
      *         The map has the same keys as the input <var>classes</var>; the
      *         values are the corresponding Class objects.
      * @throws CharSequenceCompilerException
      * if the source cannot be compiled
      */
    @throws[CharSequenceCompilerException]
    def compile(classes: Map[String, CharSequence], diagnosticsList: DiagnosticCollector[JavaFileObject]): Map[String, Class[T]] = {
      val sources = classes.map { case (qualifiedClassName, javaSource) ⇒
        val dotPos: Int = qualifiedClassName.lastIndexOf('.')
        val className =
          if (dotPos == -1)
            qualifiedClassName
          else
            qualifiedClassName.substring(dotPos + 1)
        val packageName =
          if (dotPos == -1)
            ""
          else
            qualifiedClassName.substring(0, dotPos)
        val source: JavaFileObjectImpl = new JavaFileObjectImpl(className, javaSource)
        // Store the source file in the FileManager via package/class name, adding a .java extension.
        javaFileManager.putFileForInput(StandardLocation.SOURCE_PATH, packageName, className + JAVA_EXTENSION, source)
        source
      }
      // Get a CompilationTask from the compiler and compile the sources
      val task: JavaCompiler.CompilationTask = compiler.getTask(null, javaFileManager, diagnostics, options.asJava, null, sources.asJava)
      val result = task.call
      if (result == null || !result.booleanValue)
        throw new CharSequenceCompilerException("Compilation failed.", classes.keySet, diagnostics)
      try {
        // Construct a map of class names to loaded classes.
        classes.keySet.map(qualifiedClassName ⇒
          qualifiedClassName → loadClass(qualifiedClassName)
        ).toMap
      } catch {
        case e: ClassNotFoundException => throw new CharSequenceCompilerException(classes.keySet, e, diagnostics)
        case e: IllegalArgumentException => throw new CharSequenceCompilerException(classes.keySet, e, diagnostics)
        case e: SecurityException => throw new CharSequenceCompilerException(classes.keySet, e, diagnostics)
      }
    }

    /**
      * Load a class that was generated by this instance or accessible from its
      * parent class loader. Use this method if you need access to additional
      * classes compiled by
      * {@link #compile(String, CharSequence, DiagnosticCollector, Class...) compile()},
      * for example if the primary class contained nested classes or additional
      * non-public classes.
      *
      * @param qualifiedClassName
      * the name of the compiled class you wish to load
      * @return a Class instance named by <var>qualifiedClassName</var>
      * @throws ClassNotFoundException
      * if no such class is found.
      */
    @SuppressWarnings(Array("unchecked"))
    @throws[ClassNotFoundException]
    def loadClass(qualifiedClassName: String): Class[T] = {
      classLoader.loadClass(qualifiedClassName).asInstanceOf[Class[T]]
    }
  }

  /** A [[JavaFileManager]] which manages Java source and classes. This FileManager
    * delegates to the JavaFileManager and the ClassLoaderImpl provided in the
    * constructor. The sources are all in memory CharSequence instances and the
    * classes are all in memory byte arrays.
    *
    * This FileManager forwards to the `fileManager`
    * for source and to the `classLoader` for classes
    *
    * @param theFileManager another FileManager that this instance delegates to for additional source.
    * @param classLoader    a delegating ClassLoader which contains dependent classes that the compiled classes will require when compiling them.
    */
  final class FileManagerImpl(
    val theFileManager: JavaFileManager,
    val classLoader: ClassLoaderImpl
  ) extends ForwardingJavaFileManager[JavaFileManager](theFileManager) {
    // Internal map of filename URIs to JavaFileObjects.
    private val fileObjects: mutable.Map[URI, JavaFileObject] = mutable.Map[URI, JavaFileObject]()

    /**
      * For a given file <var>location</var>, return a FileObject from which the
      * compiler can obtain source or byte code.
      *
      * @param location     an abstract file location
      * @param packageName  the package name for the file
      * @param relativeName the file's relative name
      * @return a [[FileObject]] from this or the delegated file manager
      */
    @throws[IOException]
    override def getFileForInput(location: JavaFileManager.Location, packageName: String, relativeName: String): FileObject = {
      fileObjects.getOrElse(uri(location, packageName, relativeName), super.getFileForInput(location, packageName, relativeName))
    }

    /**
      * Store a file that may be retrieved later with
      * {@link #getFileForInput(javax.tools.JavaFileManager.Location, String, String)}
      *
      * @param location     the file location
      * @param packageName  the Java class' package name
      * @param relativeName the relative name
      * @param file         the file object to store for later retrieval
      */
    def putFileForInput(location: StandardLocation, packageName: String, relativeName: String, file: JavaFileObject) {
      fileObjects.put(uri(location, packageName, relativeName), file)
    }

    /**
      * Convert a location and class name to a URI.
      */
    private def uri(location: JavaFileManager.Location, packageName: String, relativeName: String): URI = new URI(location.getName + '/' + packageName + '/' + relativeName)

    /**
      * Create a JavaFileImpl for an output class file and store it in the classloader.
      *
      * @see javax.tools.ForwardingJavaFileManager#getJavaFileForOutput(javax.tools.JavaFileManager.Location,
      *      java.lang.String, javax.tools.JavaFileObject.Kind,
      *      javax.tools.FileObject)
      */
    @throws[IOException]
    override def getJavaFileForOutput(location: JavaFileManager.Location, qualifiedName: String, kind: JavaFileObject.Kind, outputFile: FileObject): JavaFileObject = {
      val file: JavaFileObject = new JavaFileObjectImpl(qualifiedName, kind)
      classLoader.add(qualifiedName, file)
      file
    }

    override def getClassLoader(location: JavaFileManager.Location): ClassLoader = classLoader

    override def inferBinaryName(loc: JavaFileManager.Location, file: JavaFileObject): String = {
      var result: String = null
      // For our JavaFileImpl instances, return the file's name, else
      // simply run the default implementation
      if (file.isInstanceOf[JavaFileObjectImpl]) result = file.getName
      else result = super.inferBinaryName(loc, file)
      result
    }

    // TODO: This mutable code should be rewritten using Scala's immutable data structures.
    @throws[IOException]
    override def list(location: JavaFileManager.Location, packageName: String, kinds: java.util.Set[JavaFileObject.Kind], recurse: Boolean): java.lang.Iterable[JavaFileObject] = {
      val result: java.lang.Iterable[JavaFileObject] = super.list(location, packageName, kinds, recurse)
      val files: java.util.ArrayList[JavaFileObject] = new java.util.ArrayList[JavaFileObject]

      if ((location eq StandardLocation.CLASS_PATH) && kinds.contains(JavaFileObject.Kind.CLASS)) {
        for (file <- fileObjects.values) {
          if ((file.getKind eq Kind.CLASS) && file.getName.startsWith(packageName)) files.add(file)
        }
        files.addAll(classLoader.files)
      } else if ((location eq StandardLocation.SOURCE_PATH) && kinds.contains(JavaFileObject.Kind.SOURCE)) {
        for (file <- fileObjects.values) {
          if ((file.getKind eq Kind.SOURCE) && file.getName.startsWith(packageName)) files.add(file)
        }
      }
      for (file <- result.asScala) {
        files.add(file)
      }
      files
    }
  }

  /**
    * A JavaFileObject which contains either the source text or the compiler
    * generated class. This class is used in two cases.
    * <ol>
    * <li>This instance uses it to store the source which is passed to the
    * compiler. This uses the
    * {@link JavaFileObjectImpl#JavaFileObjectImpl(String, CharSequence)}
    * constructor.
    * <li>The Java compiler also creates instances (indirectly through the
    * FileManagerImplFileManager) when it wants to create a JavaFileObject for the
    * .class output. This uses the
    * {@link JavaFileObjectImpl#JavaFileObjectImpl(String, JavaFileObject.Kind)}
    * constructor.
    * </ol>
    * This class does not attempt to reuse instances (there does not seem to be a
    * need, as it would require adding a Map for the purpose, and this would also
    * prevent garbage collection of class byte code.)
    */
  final class JavaFileObjectImpl(name: String, source: CharSequence, kind: JavaFileObject.Kind) extends SimpleJavaFileObject(new URI(name), kind) {
    // If kind == CLASS, this stores byte code from openOutputStream
    private var byteCode: ByteArrayOutputStream = null // This is mutable because `openInputStream()` will create a new stream on every call.
    // if kind == SOURCE, this contains the source text

    /**
      * Construct a new instance which stores source.
      *
      * @param baseName the base name
      * @param source   the source code
      */
    def this(baseName: String, source: CharSequence) {
      this(baseName + JAVA_EXTENSION, source, Kind.SOURCE)
    }

    def this(name: String, kind: JavaFileObject.Kind) {
      this(name, null, kind)
    }

    /**
      * Return the source code content.
      *
      * @see javax.tools.SimpleJavaFileObject#getCharContent(boolean)
      */
    @throws[UnsupportedOperationException]
    override def getCharContent(ignoreEncodingErrors: Boolean): CharSequence = {
      if (source == null) throw new UnsupportedOperationException("getCharContent()")
      source
    }

    /**
      * Return an input stream for reading the byte code
      *
      * @see javax.tools.SimpleJavaFileObject#openInputStream()
      */
    override def openInputStream: InputStream = new ByteArrayInputStream(getByteCode)

    /**
      * Return an output stream for writing the bytecode
      *
      * @see javax.tools.SimpleJavaFileObject#openOutputStream()
      */
    override def openOutputStream: OutputStream = {
      byteCode = new ByteArrayOutputStream
      byteCode
    }

    /**
      * @return the byte code generated by the compiler
      */
    private[javacompiler] def getByteCode: Array[Byte] = byteCode.toByteArray
  }

  /**
    * A custom ClassLoader which maps class names to JavaFileObjectImpl instances.
    */
  final class ClassLoaderImpl private[javacompiler](parentClassLoader: ClassLoader) extends ClassLoader(parentClassLoader) {
    private val classes: java.util.Map[String, JavaFileObject] = new java.util.HashMap[String, JavaFileObject]

    /**
      * @return An collection of JavaFileObject instances for the classes in the
      *         class loader.
      */
    private[javacompiler] def files: java.util.Collection[JavaFileObject] = java.util.Collections.unmodifiableCollection(classes.values)

    @throws[ClassNotFoundException]
    override protected def findClass(qualifiedClassName: String): Class[_] = {
      val file: JavaFileObject = classes.get(qualifiedClassName)
      if (file != null) {
        val bytes: Array[Byte] = file.asInstanceOf[JavaFileObjectImpl].getByteCode
        return defineClass(qualifiedClassName, bytes, 0, bytes.length)
      }
      // Workaround for "feature" in Java 6
      // see http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6434149
      try {
        Class.forName(qualifiedClassName)
      } catch {
        case nf: ClassNotFoundException =>
        // Ignore and fall through
      }
      super.findClass(qualifiedClassName)
    }

    /**
      * Add a class name/JavaFileObject mapping
      *
      * @param qualifiedClassName
      * the name
      * @param javaFile
      * the file associated with the name
      */
    private[javacompiler] def add(qualifiedClassName: String, javaFile: JavaFileObject) {
      classes.put(qualifiedClassName, javaFile)
    }

    @throws[ClassNotFoundException]
    override protected def loadClass(name: String, resolve: Boolean): Class[_] = super.loadClass(name, resolve)

    override def getResourceAsStream(name: String): InputStream = {
      if (name.endsWith(".class")) {
        val qualifiedClassName: String = name.substring(0, name.length - ".class".length).replace('/', '.')
        val file: JavaFileObjectImpl = classes.get(qualifiedClassName).asInstanceOf[JavaFileObjectImpl]
        if (file != null) return new ByteArrayInputStream(file.getByteCode)
      }
      super.getResourceAsStream(name)
    }
  }

  /**
    * An exception thrown when trying to compile Java programs from strings
    * containing source.
    *
    * @author <a href="mailto:David.Biesack@sas.com">David J. Biesack</a>
    * @param message             The exception's message.
    * @param cause               Cause of the exception.
    * @param qualifiedClassNames Classes whose compilation caused an exception.
    * @param diagnostics         Diagnostic output for compilation errors.
    */
  @SerialVersionUID(1L)
  class CharSequenceCompilerException(
    message: String,
    cause: Throwable,
    qualifiedClassNames: Set[String],
    diagnostics: DiagnosticCollector[JavaFileObject]
  ) extends Exception(message, cause) {

    def this(message: String, qualifiedClassNames: Set[String], diagnostics: DiagnosticCollector[JavaFileObject]) {
      this(message, null, qualifiedClassNames, diagnostics)
    }

    def this(qualifiedClassNames: Set[String], cause: Throwable, diagnostics: DiagnosticCollector[JavaFileObject]) {
      this(cause.toString, cause, qualifiedClassNames, diagnostics)
    }
  }

}

